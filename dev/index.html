<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home ¬∑ VKcurve.jl</title><meta name="title" content="Home ¬∑ VKcurve.jl"/><meta property="og:title" content="Home ¬∑ VKcurve.jl"/><meta property="twitter:title" content="Home ¬∑ VKcurve.jl"/><meta name="description" content="Documentation for VKcurve.jl."/><meta property="og:description" content="Documentation for VKcurve.jl."/><meta property="twitter:description" content="Documentation for VKcurve.jl."/><meta property="og:url" content="https://jmichel7.github.io/VKcurve.jl/"/><meta property="twitter:url" content="https://jmichel7.github.io/VKcurve.jl/"/><link rel="canonical" href="https://jmichel7.github.io/VKcurve.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>VKcurve.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jmichel7/VKcurve.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jmichel7/VKcurve.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="VKcurve"><a class="docs-heading-anchor" href="#VKcurve">VKcurve</a><a id="VKcurve-1"></a><a class="docs-heading-anchor-permalink" href="#VKcurve" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/jmichel7/VKcurve.jl">VKcurve</a>.</p><article><details class="docstring" open="true"><summary id="VKcurve.VKcurve"><a class="docstring-binding" href="#VKcurve.VKcurve"><code>VKcurve.VKcurve</code></a> ‚Äî <span class="docstring-category">Module</span></summary><section><div><p>This  package is  a port  to Julia  of the  GAP3 package VKcurve written by David Bessis and Jean Michel in 2002.</p><p>The  main function  computes the  fundamental group  of the complement of a complex  algebraic curve in <code>‚ÑÇ¬≤</code>, using an implementation of the Van Kampen method; see for example</p><p>D. Cheniot. &quot;Une d√©monstration du th√©or√®me de   Zariski sur les sections hyperplanes d&#39;une hypersurface projective et du   th√©or√®me de Van Kampen sur le groupe fondamental du   compl√©mentaire d&#39;une courbe projective plane.&quot; Compositio Math., 27:141‚Äì158, 1973.</p><p>for a clear and modernized account of this method. Here is are examples for curves defined as the zeros of two-variable polynomials in <code>x</code> and <code>y</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using PuiseuxPolynomials, VKcurve

julia&gt; @Mvp x,y</code></pre><pre><code class="language-julia-rep1 hljs">julia&gt; fundamental_group((x+y)*(x-y*im)*(x+2*y))
Presentation: 3 generators, 2 relators, total length 12
1: abc=bca
2: cab=abc</code></pre><pre><code class="language-julia-repl hljs">julia&gt; r=fundamental_group(x^2-y^3); # the braid group on 3 strands
Presentation: 2 generators, 1 relator, total length 6

julia&gt; r
1: bab=aba</code></pre><p>Here we define the variables and then give the curves as argument. Although approximate  computations are used  in several places,  they are controlled and  the final result is exact;  technically speaking, the computations use <code>Rational{BigInt}</code> or <code>Complex{Rational{BigInt}}</code> since the precision given by  floats  is  insufficient.  It  might  be  possible  to use intervals of bigfloats  to make calculations faster, but this would make the programming more  difficult.  If  you  have  a  polynomial with float coefficients, you should convert the coefficients to <code>Complex{Rational{BigInt}}</code> (if they are of  any integer or rational type, or of type <code>Complex{&lt;:Integer}</code> they will be converted internally to <code>Complex{Rational{BigInt}}</code>).</p><p>The  output is  a <code>struct</code>  which contains  a lot  of information about the calculation,  including a  presentation of  the computed fundamental group, which is what is displayed by default when printing it.</p><p>Our  motivation  for  writing  this  package  in  2002 was to find explicit presentations  for generalized braid groups associated with certain complex reflection  groups. Although presentations were known for almost all cases, six  exceptional cases were missing (in the notations of Shephard and Todd, these  cases are  <code>G‚ÇÇ‚ÇÑ</code>, <code>G‚ÇÇ‚Çá</code>,  <code>G‚ÇÇ‚Çâ</code>, <code>G‚ÇÉ‚ÇÅ</code>,  <code>G‚ÇÉ‚ÇÉ</code> and <code>G‚ÇÉ‚ÇÑ</code>). Since the existence of nice presentations for braid groups was proved (non-constructively) in</p><p>D. Bessis. &quot;Zariski theorems and diagrams for braid groups.&quot;, Invent. Math. 145:487‚Äì507, 2001</p><p>it  was upsetting not to  know them explicitly. In  the absence of any good grip  on the  geometry of  these six  examples, brute force (using VKcurve) gave  us we have  obtained presentations for  all of them  (they have since been  confirmed by less  computational methods). These  computations can be reproduced by <a href="#Chevie.Semisimple.fundamental_group-Tuple{PuiseuxPolynomials.Mvp}"><code>fundamental_group</code></a><code>(VKcurve.data[i])</code> where <code>i‚àà{23,24,27,29,31,33,34}</code>.</p><p>If  you  are  not  interested  in  the  details  of  the  algorithm, and if <code>fundamental_group</code>,  as  in  the  examples  above,  gives you satisfactory answers  in a reasonable time, then you do not need to read this manual any further.</p><p>In  order to implement the algorithm, we had to write auxiliary facilities, for  example to find <code>Complex{Rational}</code> approximations of zeros of complex polynomials,  or to work with piecewise  linear braids, which can be useful facilities in themselves. These are documented in this manual.</p><p>Before  discussing  our  actual  implementation,  let  us  give an informal summary  of the mathematical  background. Our strategy  is adapted from the one  originally described in the 1930&#39;s by Van Kampen. Let <code>C</code> be an affine algebraic  curve, given as the  set of zeros in  <code>‚ÑÇ¬≤</code> of a non-zero reduced polynomial  <code>P(x,y)</code>.  The  problem  is  to  compute  a presentation of the fundamental  group of  <code>‚ÑÇ¬≤-C</code>. Consider  <code>P</code> as  a polynomial  in <code>x</code>, with coefficients  in the ring  of polynomials in  <code>y</code>, that is <code>P=Œ±‚ÇÄ(y)x‚Åø+Œ±‚ÇÅ(y) x‚Åø‚Åª¬π+‚Ä¶+Œ±‚Çô‚Çã‚ÇÅ(y)x+Œ±‚Çô(y)</code>, where the <code>Œ±·µ¢‚àà‚ÑÇ[y]</code>. Let <code>Œî(y)</code> be the discriminant of  <code>P</code> or, in other words, the resultant  of <code>P</code> and <code>‚àÇP/‚àÇx</code>. Since <code>P</code> is reduced,  <code>Œî</code> is non-zero. Let <code>y‚ÇÅ,‚Ä¶,y_d</code> be the roots of the corresponding reduced polynomial <code>Œî_{red}</code>. For a generic value of <code>y</code>, the polynomial in <code>x</code>  given by  <code>P(x,y)</code> has  <code>n</code> distinct  roots. When  <code>y=y‚±º</code>, with <code>j</code> in <code>1,‚Ä¶,d</code>,  we  are  in  exactly  one  of  the  following  situations: either <code>P(x,y‚±º)=0</code>  (we then say that  <code>y‚±º</code> is bad), or  <code>P(x,y‚±º)</code> has a number of roots  in  <code>x</code>  strictly  smaller  than  <code>n</code>.  Fix  <code>y‚ÇÄ</code> in <code>‚ÑÇ-{y‚ÇÅ,‚Ä¶,y_d}</code>. Consider  the projection <code>p:  ‚ÑÇ¬≤‚Üí ‚ÑÇ, (x,y)‚Ü¶  y</code>. It restricts  to a locally trivial  fibration with base space <code>B=‚ÑÇ-{y‚ÇÅ,‚Ä¶,y_d}</code> and fibers homeomorphic to  the complex plane with  <code>n</code> points removed. We  denote by <code>E</code> the total space <code>p‚Åª¬π(B)</code> and by <code>F</code> the fiber over <code>y‚ÇÄ</code>. The fundamental group of <code>F</code> is  isomorphic to the free group on <code>n</code> generators. Let <code>Œ≥‚ÇÅ,‚Ä¶,Œ≥_d</code> be loops in  the  pointed  space  <code>(B,y‚ÇÄ)</code>  representing  a  generating  system  for <code>œÄ‚ÇÅ(B,y‚ÇÄ)</code>.  By trivializing  the pullback  of <code>p</code>  along <code>Œ≥·µ¢</code>,  one gets a (well-defined  up to  isotopy) homeomorphism  of <code>F</code>,  and a (well-defined) automorphism <code>œÜ·µ¢</code> of the fundamental group of <code>F</code>, identified with the free group <code>F‚Çô</code> by the choice of a generating system <code>f‚ÇÅ,‚Ä¶,f‚Çô</code>. An effective way of  computing <code>œÜ·µ¢</code> is by following the solutions in <code>x</code> of <code>P(x,y)=0</code>, when <code>y</code>  moves along <code>œÜ·µ¢</code>. This defines a loop in the space of configuration of <code>n</code>  points in a plane, hence an element  <code>b·µ¢</code> of the braid group <code>B‚Çô</code> (via an  identification of <code>B‚Çô</code> with the fundamental group of this configuration space).  Let <code>œÜ</code> be the Hurwitz action of  <code>B‚Çô</code> on <code>F‚Çô</code>. All choices can be made in such a way that <code>œÜ·µ¢=œÜ(b·µ¢)</code>. The theorem of Van Kampen asserts that, if  there are  no bad  roots of  the discriminant,  a presentation  for the fundamental group of <code>‚ÑÇ¬≤-C</code> is <code>‚ü®f‚ÇÅ,‚Ä¶,f‚Çô‚à£‚àÄi,j,œÜ·µ¢(f‚±º)=f‚±º‚ü©</code>. A variant of the above  presentation (see <a href="#VKcurve.VKquotient"><code>VKquotient</code></a>) can be used to deal with bad roots of the discriminant.</p><p>This algorithm is implemented in the following way.</p><ul><li><p>As input, we have a polynomial <code>P</code>. We reduce <code>P</code> if it was not.</p></li><li><p>The discriminant <code>Œî</code> of <code>P</code> with respect to <code>x</code>, a polynomial in <code>y</code>, is computed.</p></li><li><p>The  roots  of  <code>Œî</code>  are  approximated,  via  the  following procedure. First,  we reduce <code>Œî</code> and get  <code>Œî_{red}</code> (generating the radical of the ideal  generated  by  <code>Œî</code>).  The  roots  <code>{y‚ÇÅ,‚Ä¶,y_d}</code>  of <code>Œî_{red}</code> are separated  by <a href="#VKcurve.separate_roots"><code>separate_roots</code></a> (which  uses Newton&#39;s method and continuous fraction aprroximations).</p></li><li><p>Loops around these roots are computed by <a href="#VKcurve.loops_around_punctures"><code>loops_around_punctures</code></a>. This  function first computes  some sort of  honeycomb, consisting of a set  <code>S</code> of  affine segments,  isolating the  <code>y·µ¢</code>. Since  it makes the computation  of the monodromy  more effective, each  inner segment is a fragment  of the mediatrix of two roots of <code>Œî</code>. Then a vertex of one of the  segments is chosen as a basepoint, and the function returns a list of  lists of oriented segments  in <code>S</code>: each list of segments encodes a piecewise linear loop <code>Œ≥·µ¢</code> circling one of <code>y·µ¢</code>.</p></li><li><p>For each  segment in  <code>S</code>, we  compute the  monodromy braid obtained by following  the solutions in <code>x</code> of  <code>P(x,y)=0</code> when <code>y</code> moves along the segment. By default, this monodromy braid is computed by <a href="#VKcurve.follow_monodromy"><code>follow_monodromy</code></a>. The strategy is to compute a piecewise-linear  braid  approximating  the  actual monodromy geometric braid. The approximations are controlled. The piecewise-linear braid is constructed  step-by-step, by computations of linear pieces. As soon as new  piece is constructed, it is converted  into an element of <code>B‚Çô</code> and multiplied; therefore, though the braid may consist of a huge number of pieces, the function <code>follow_monodromy</code> works with constant memory. The package  also  contains  a  variant  <a href="#VKcurve.approx_follow_monodromy"><code>approx_follow_monodromy</code></a>, which runs faster, but without guarantee on the result (see below).</p></li><li><p>The monodromy braids <code>b·µ¢</code> corresponding  to the loops <code>Œ≥·µ¢</code> are obtained by  multiplying the monodromy braids  of the correponding segments. The action  of these elements of <code>B‚Çô</code> on the free group <code>F‚Çô</code> is computed by <code>hurwitz</code>  and the resulting  presentation of the  fundamental group is computed  by <a href="#VKcurve.VKquotient"><code>VKquotient</code></a>.  It happens  for some large problems that the whole process fails here, because the braids <code>b·µ¢</code> obtained are too  long and the computation  of the action on  <code>F‚Çô</code> requires thus too much  memory. We have been able to  solve such problems when they occur by  calling at  this stage  our function  <code>shrink</code> which  finds smaller generators  for the  subgroup of  <code>B‚Çô</code> generated  by the  <code>b·µ¢</code> (see the description   in   <code>Chevie.Garside</code>).   This   function  is  called  if <code>VK.shrinkBraid==true</code>.</p></li><li><p>Finally, the presentation is simplified by <code>simplify</code>. This function is a   heuristic   function   for   simplifying   presentations.   It   is non-deterministic.</p></li></ul><p>From  an algorithmic point of view, memory  should not be an issue, but the procedure  can  take  a  lot  of  CPU  time  (the  critical  part being the computation of the monodromy braids by <code>follow_monodromy</code>). For example, an empirical  study with  the curves  <code>x¬≤-y‚Åø</code> suggests  that the time required grows  exponentially with <code>n</code>.  The variable <code>VK.approx_monodromy</code> controls which  monodromy function  is used.  The default  value of this variable is <code>false</code>,  which means that  <code>follow_monodromy</code> is used.  If the variable is set  to <code>true</code> then <code>approx_follow_monodromy</code> is used, where approximations are   no   longer   controlled.   Therefore  presentations  obtained  while <code>VK.approx_monodromy</code>  is  set  to  <code>true</code>  will not be certified. However, while  it is likely that there are examples where <code>approx_follow_monodromy</code> actually returns incorrect answers, we have not yet seen any.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/VKcurve.jl/blob/3f51930ef2146615bfe9bdcfe6e35a48a92cd8c9/src/VKcurve.jl#L1-L178">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Chevie.Semisimple.fundamental_group-Tuple{PuiseuxPolynomials.Mvp}"><a class="docstring-binding" href="#Chevie.Semisimple.fundamental_group-Tuple{PuiseuxPolynomials.Mvp}"><code>Chevie.Semisimple.fundamental_group</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p><code>fundamental_group(curve::Mvp; verbose=0)</code></p><p><code>curve</code> should be an <code>Mvp</code> in <code>x</code> and <code>y</code> representing an equation <code>f(x,y)</code> for  a  curve  in  <code>‚ÑÇ¬≤</code>.  The  coefficients  should be integers, rationals, gaussian  integers or  gaussian rationals.  The result  is a  record with a certain number of fields which record steps in the computation described in this introduction:</p><pre><code class="language-julia-repl hljs">julia&gt; @Mvp x,y

julia&gt; r=fundamental_group(x^2-y^3)
Presentation: 2 generators, 1 relator, total length 6
1: bab=aba

julia&gt; propertynames(r)
(:curve, :ismonic, :prop, :rawPresentation, :B, :basepoint, :dispersal, :monodromy, :discyFactored, :segments, :braids, :roots, :nonVerticalPart, :discy, :zeros, :curveVerticalPart, :points, :loops, :presentation)

julia&gt; r.curve # the given equation
Mvp{Rational{BigInt}}: (1//1)x¬≤+(-1//1)y¬≥

julia&gt; Pol(:y);r.discy # its discriminant wrt x
Pol{Rational{BigInt}}: y

julia&gt; r.roots  # roots of the discriminant
1-element Vector{Rational{BigInt}}:
 0

julia&gt; r.points # for points, segments and loops see loops_around_punctures
4-element Vector{Complex{Rational{BigInt}}}:
  0//1 - 1//1*im
 -1//1 + 0//1*im
  1//1 + 0//1*im
  0//1 + 1//1*im

julia&gt; r.segments
4-element Vector{Vector{Int64}}:
 [1, 2]
 [1, 3]
 [2, 4]
 [3, 4]

julia&gt; r.loops
1-element Vector{Vector{Int64}}:
 [4, -3, -1, 2]

julia&gt; r.zeros # zeroes of curve(y=pt) when pt runs over r.points
4-element Vector{Vector{Complex{Rational{BigInt}}}}:
 [5741//8119 + 5741//8119*im, -5741//8119 - 5741//8119*im]
 [0//1 + 1//1*im, 0//1 - 1//1*im]
 [1//1 + 0//1*im, -1//1 + 0//1*im]
 [-5741//8119 + 5741//8119*im, 5741//8119 - 5741//8119*im]

julia&gt; r.monodromy # monodromy around each r.segment
4-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:
 (Œî)‚Åª¬π
 Œî
 .
 Œî

julia&gt; r.braids # monodromy around each r.loop
1-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:
 Œî¬≥</code></pre><pre><code class="language-julia-rep1 hljs">julia&gt; display_balanced(r.presentation) # printing of r by default
1: bab=aba</code></pre><p>The  keyword argument <code>verbose</code> triggers the  display of information on the progress of the computation. It is recommended to set it at 1 or 2 when the computation seems to take a long time without doing anything. <code>verbose</code> set at  0 is the default and prints nothing; set at 1 it shows which segment is currently  active,  and  set  at  2  it  traces the computation inside each segment.</p><pre><code class="language-julia-rep1 hljs">julia&gt; fundamental_group(x^2-y^3,verbose=1);
# There are 4 segments in 1 loops
# follow_monodromy along segment 1/4  in   8 steps/  0.012sec got B(-1)
# follow_monodromy along segment 2/4  in   8 steps/ 0.00752sec got B(1)
# follow_monodromy along segment 3/4  in   8 steps/ 0.00557sec got B()
# follow_monodromy along segment 4/4  in   8 steps/ 0.00457sec got B(1)
# Computing monodromy braids along loops
[r.B(1,1,1),]
#I total length 3 maximal length 3

Presentation: 2 generators, 1 relator, total length 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/VKcurve.jl/blob/3f51930ef2146615bfe9bdcfe6e35a48a92cd8c9/src/VKcurve.jl#L259-L347">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VKcurve.simp"><a class="docstring-binding" href="#VKcurve.simp"><code>VKcurve.simp</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p><code>VKcurve.simp(t::Real;prec=10^-15,type=BigInt)</code></p><p>simplest fraction of type <code>Rational{T}</code> approximating <code>t</code> closer than prec.</p><pre><code class="language-julia-repl hljs">julia&gt; VKcurve.simp(float(œÄ);prec=10^-6)
355//113</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/VKcurve.jl/blob/3f51930ef2146615bfe9bdcfe6e35a48a92cd8c9/src/VKcurve.jl#L516-L524">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VKcurve.NewtonRoot"><a class="docstring-binding" href="#VKcurve.NewtonRoot"><code>VKcurve.NewtonRoot</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p><code>VKcurve.NewtonRoot(p::Pol,initial_guess,precision::Real;showall=false,show=false,lim=800)</code></p><p>Here   <code>p</code>  is   a  polynomial   with  <code>Rational</code>   or  <code>Complex{Rational}</code> coefficients.  The function  computes an  approximation to  a root  of <code>p</code>, guaranteed of distance closer than <code>precision</code> to an actual root. The first approximation  used is <code>initial</code>.  A possibility is  that the Newton method starting  from <code>initial</code> does not converge  (the number of iterations after which  this is decided  is controlled by  <code>lim</code>); then the function returns <code>nothing</code>.  Otherwise the function returns a pair: the approximation found, and an upper bound on the distance between that approximation and an actual root.  The point of returning  an upper bound is  that it is usually better than the asked-for <code>precision</code>. For the precision estimate a good reference is</p><p>J.  Hubbard, D. Schleicher,  and S. Sutherland.  &quot;How to find  all roots of complex polynomials by Newton&#39;s method.&quot;, Invent. Math. 146:1‚Äì33, 2001.</p><pre><code class="language-julia-repl hljs">julia&gt; p=Pol([1,0,1])
Pol{Int64}: y¬≤+1

julia&gt; VKcurve.NewtonRoot(p,1+im,10^-4)
(0//1 + 1//1*im, 3.333333333333333e-7)</code></pre><pre><code class="language-julia-rep1 hljs">julia&gt; VKcurve.NewtonRoot(p,1,10^-4;show=true)
****** Non-Convergent Newton after 800 iterations ******
(p, z, precision) = (Pol([1, 0, 1]), -1//1, 0.0001)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/VKcurve.jl/blob/3f51930ef2146615bfe9bdcfe6e35a48a92cd8c9/src/VKcurve.jl#L543-L573">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VKcurve.separate_roots"><a class="docstring-binding" href="#VKcurve.separate_roots"><code>VKcurve.separate_roots</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p><code>VKcurve.separate_roots(p::Pol, safety)</code></p><p>Here  <code>p</code> is  a complex  polynomial. The  result is  a list  <code>l</code> of complex numbers  representing approximations to the roots  of <code>p</code>, such that if <code>d</code> is  the minimum distance between two elements  of <code>l</code>, then there is a root of  <code>p</code> within  radius <code>d/(2*safety)</code>  of any  element of  <code>l</code>. This is not possible when <code>p</code> has multiple roots, in which case <code>nothing</code> is returned.</p><pre><code class="language-julia-repl hljs">julia&gt; @Pol q
Pol{Int64}: q

julia&gt; VKcurve.separate_roots(q^2+1,100)
2-element Vector{Complex{Rational{BigInt}}}:
 0//1 + 1//1*im
 0//1 - 1//1*im

julia&gt; VKcurve.separate_roots((q-1)^2,100)

julia&gt; VKcurve.separate_roots(q^3-1,100)
3-element Vector{Complex{Rational{BigInt}}}:
 -1//2 - 181//209*im
  1//1 + 0//1*im
 -1//2 + 181//209*im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/VKcurve.jl/blob/3f51930ef2146615bfe9bdcfe6e35a48a92cd8c9/src/VKcurve.jl#L637-L663">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VKcurve.find_roots"><a class="docstring-binding" href="#VKcurve.find_roots"><code>VKcurve.find_roots</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p><code>VKcurve.find_roots(p::Pol, approx)</code></p><p><code>p</code>  should have rational or  <code>Complex{Rational} coefficients. The function returns</code>Complex<code>rational  approximations to  the roots  of</code>p<code>which are better  than</code>approx<code>(a  positive  rational).  Contrary to the functions</code>separate_roots`,  etc... described in the  previous chapter, this function handles  quite  well  polynomials  with  multiple  roots.  We  rely  on the algorithms explained in detail in cite{HSS01}.</p><pre><code class="language-julia-repl hljs">julia&gt; VKcurve.find_roots((Pol()-1)^5,1/1000)
5-element Vector{Complex{Rational{BigInt}}}:
 1//1 + 0//1*im
 1//1 + 0//1*im
 1//1 + 0//1*im
 1//1 + 0//1*im
 1//1 + 0//1*im

julia&gt; l=VKcurve.find_roots(Pol()^3-1,10^-5)
3-element Vector{Complex{Rational{BigInt}}}:
 -1//2 - 16296//18817*im
  1//1 + 0//1*im
 -1//2 + 16296//18817*im

julia&gt; round.(Complex{Float64}.(l.^3);sigdigits=3)
3-element Vector{ComplexF64}:
 1.0 - 1.83e-9im
 1.0 + 0.0im
 1.0 + 1.83e-9im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/VKcurve.jl/blob/3f51930ef2146615bfe9bdcfe6e35a48a92cd8c9/src/VKcurve.jl#L690-L721">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VKcurve.nearest_pair"><a class="docstring-binding" href="#VKcurve.nearest_pair"><code>VKcurve.nearest_pair</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p><code>VKcurve.nearest_pair(v::Vector{&lt;:Complex})</code></p><p>returns  a pair whose first element is the minimum distance (in the complex plane)  between two elements  of <code>v</code>, and  the second is  a pair of indices <code>[i,j]</code> such that <code>v[i],v[j]</code> achieves this minimum.</p><p>julia&gt; nearest_pair([1+im,0,1]) 1=&gt;[1,3]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/VKcurve.jl/blob/3f51930ef2146615bfe9bdcfe6e35a48a92cd8c9/src/VKcurve.jl#L183-L192">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VKcurve.dist_seg"><a class="docstring-binding" href="#VKcurve.dist_seg"><code>VKcurve.dist_seg</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p><code>dist_seg(z,a,b)</code> distance (in the complex plane) of <code>z</code> to segment <code>[a,b]</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/VKcurve.jl/blob/3f51930ef2146615bfe9bdcfe6e35a48a92cd8c9/src/VKcurve.jl#L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VKcurve.loops_around_punctures"><a class="docstring-binding" href="#VKcurve.loops_around_punctures"><code>VKcurve.loops_around_punctures</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p><code>VKcurve.loops_around_punctures(points)</code></p><p><code>points</code>  should  be  a  list  of  complex  numbers.  The function computes piecewise-linear  loops representing generators of the fundamental group of <code>‚ÑÇ -{points}</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; VKcurve.loops_around_punctures([0])
1-element Vector{Vector{Complex{Int64}}}:
 [1 + 0im, 0 + 1im, -1 + 0im, 0 - 1im, 1 + 0im]</code></pre><p>Guarantees on the result: for  a set <code>Z</code> of zeroes and <code>z‚ààZ</code>, let <code>R(z):=dist(z,Z-z)/2</code>. The input of <code>points</code>  is a set <code>Z</code> of approximate zeroes of <code>r.discy</code> such that for any <code>z</code>  one  of  the  zeroes  is  closer  than  <code>R(z)/S</code> where <code>S</code> is a global constant   of  the  program   (in  practice  we   may  take  <code>S=100</code>).  Let <code>d=inf_{z‚ààZ}(R(z))</code>;   we  return   points  with   denominator  <code>10^-k</code>  or <code>10^-k&lt;d/S&#39;</code> (in practive we take <code>S&#39;=100</code>) and such that the distance of a segment to a zero of <code>r.discy</code> is guaranteed <code>&gt;= d-d/S&#39;-d/S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/VKcurve.jl/blob/3f51930ef2146615bfe9bdcfe6e35a48a92cd8c9/src/VKcurve.jl#L884-L904">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VKcurve.convert_loops"><a class="docstring-binding" href="#VKcurve.convert_loops"><code>VKcurve.convert_loops</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p><code>VKcurve.convert_loops(ll)</code></p><p>The  input is a list  of loops, each a  list of complex numbers representing the vertices of the loop.</p><p>The output is a named tuple with fields</p><ul><li><code>points</code>: a list of complex  numbers.</li><li><code>segments</code>:  a list of oriented segments, each of them  encoded by the list of the positions in <code>points</code> of  its two endpoints.</li><li><code>loops</code>: a list of loops. Each loops is a list  of integers representing a  piecewise  linear  loop,  obtained  by  concatenating the <code>segments</code> indexed  by the  integers, where  a negative  integer is  used when the opposed orientation of the segment is taken.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/VKcurve.jl/blob/3f51930ef2146615bfe9bdcfe6e35a48a92cd8c9/src/VKcurve.jl#L834-L848">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VKcurve.follow_monodromy"><a class="docstring-binding" href="#VKcurve.follow_monodromy"><code>VKcurve.follow_monodromy</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p><code>VKcurve.follow_monodromy(r,segno)</code> This  function computes the  monodromy braid of  the solution in  <code>x</code> of an equation   <code>P(x,y)=0</code>  along   a  segment   <code>[y‚ÇÄ,y‚ÇÅ]</code>.  It   is  called  by <code>fundamental_group</code>  for each  segment in  turn. The  first argument is the record containing intermediate information computed by <code>fundamental_group</code>. The second argument is the index of the segment in <code>r.segments</code>.</p><p>The function returns an element of the ambient braid group <code>r.B</code>.</p><p>This function has no reason to be called directly by the user, so we do not illustrate  its behavior. Instead,  we explain what  is displayed on screen when the user sets <code>verbose=2</code>.</p><p>What is quoted below is an excerpt of what is printed during the execution of</p><pre><code class="language-julia_rep1 hljs">julia&gt; fundamental_group((x+3*y)*(x+y-1)*(x-y),verbose=2)
......
segment 1/16 step   1 time=0           ?2?1?3
segment 1/16 step   2 time=0.2         R2. ?3
segment 1/16 step   3 time=0.48        R2. ?2
segment 1/16 step   4 time=0.74        ?2R1?2
segment 1/16 step   5 time=0.94        R1. ?2
======================================
==    Nontrivial braiding B(2)      ==
======================================
segment 1/16 step   6 time=0.bc        R1. ?1
segment 1/16 step   7 time=0.d8        . ?0. 
segment 1/16 step   8 time=0.dc        ?1R0?1
# follow_monodromy(segment 1/16) in   8 steps/ 0.0209sec got B(2)</code></pre><p><code>follow_monodromy</code>  computes its  results by  subdividing the  segment into smaller  subsegments on which the  approximations are controlled. It starts at  one end and moves subsegment after  subsegment. A new line is displayed at each step.</p><p>The  first column indicates which segment  is studied. The second column is the  number of iterations  so far (number  of subsegments). In our example, <code>follow_monodromy</code>  had  to  cut  the  segment  into  <code>8</code> subsegments. Each subsegment  has its own length. The cumulative length at a given step, as a fraction  of the total  length of the  segment, is displayed after <code>time=</code>. This  gives a rough  indication of the  time left before  completion of the computation of the monodromy of this segment. The segment is completed when this fraction reaches <code>1</code>.</p><p>The  last column has  to do with  the piecewise-linear approximation of the geometric  monodromy  braid.  It  is  subdivided  into sub-columns for each string.  In the example above, there are  three strings. At each step, some strings are fixed (they are indicated by <code>.</code> in the corresponding column). A  symbol like <code>R5</code> or <code>?3</code> indicates  that the string is moving. The exact meaning   of  the  symbol  has  to   do  with  the  complexity  of  certain sub-computations.</p><p>As  some strings are moving, it  happens that their real projections cross. When  such a crossing occurs, it  is detected and the corresponding element of  <code>B‚Çô</code> is displayed (<code>Nontrivial braiding  =</code>...). The monodromy braid is the  product of these  elements of <code>B‚Çô</code>,  multiplied in the  order in which they occur.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/VKcurve.jl/blob/3f51930ef2146615bfe9bdcfe6e35a48a92cd8c9/src/VKcurve.jl#L1265-L1323">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VKcurve.approx_follow_monodromy"><a class="docstring-binding" href="#VKcurve.approx_follow_monodromy"><code>VKcurve.approx_follow_monodromy</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p><code>VKcurve.approx_follow_monodromy(&lt;r&gt;,&lt;segno&gt;,&lt;pr&gt;)</code></p><p>This function  computes an approximation  of the monodromy braid  of the solution in <code>x</code>  of an equation <code>P(x,y)=0</code> along  a segment <code>[y‚ÇÄ,y‚ÇÅ]</code>. It is called  by <code>fundamental_group</code>, once for each of  the segments. The first  argument is  a  global record,  similar to  the  one produced  by <code>fundamental_group</code>  (see the  documentation of  this function)  but only containing intermediate information. The second argument is the position of the segment in <code>r.segments</code>. </p><p>Contrary  to <code>follow_monodromy</code>, <code>approx_follow_monodromy</code> does not control the approximations; it just uses a heuristic for how much to move along the segment  between linear braid computations, and this heuristic may possibly fail.  However, we have  not yet found  an example for  which the result is actually  incorrect, and thus  the existence is  justified by the fact that for  some difficult  computations, it  is sometimes  many times faster than <code>follow_monodromy</code>. We illustrate its typical output when <code>verbose=2</code>:</p><pre><code class="language-julia-rep1 hljs">julia&gt; VK.approx_monodromy=true

julia&gt; fundamental_group((x+3*y)*(x+y-1)*(x-y);verbose=2)

  ....

546 ***rejected
447&lt;15/16&gt;mindist=2.55 step=0.5 total=0 logdisc=0.55 ***rejected
435&lt;15/16&gt;mindist=2.55 step=0.25 total=0 logdisc=0.455 ***rejected
334&lt;15/16&gt;mindist=2.55 step=0.125 total=0 logdisc=0.412 ***rejected
334&lt;15/16&gt;mindist=2.55 step=0.0625 total=0 logdisc=0.393
334&lt;15/16&gt;mindist=2.55 step=0.0625 total=0.0625 logdisc=0.412
334&lt;15/16&gt;mindist=2.56 step=0.0625 total=0.125 logdisc=0.433
334&lt;15/16&gt;mindist=2.57 step=0.0625 total=0.1875 logdisc=0.455
334&lt;15/16&gt;mindist=2.58 step=0.0625 total=0.25 logdisc=0.477
======================================
==    Nontrivial braiding B(2)      ==
======================================
334&lt;15/16&gt;mindist=2.6 step=0.0625 total=0.3125 logdisc=0.501
334&lt;15/16&gt;mindist=2.63 step=0.0625 total=0.375 logdisc=0.525
334&lt;15/16&gt;mindist=2.66 step=0.0625 total=0.4375 logdisc=0.55
334&lt;15/16&gt;mindist=2.69 step=0.0625 total=0.5 logdisc=0.576
334&lt;15/16&gt;mindist=2.72 step=0.0625 total=0.5625 logdisc=0.602
334&lt;15/16&gt;mindist=2.76 step=0.0625 total=0.625 logdisc=0.628
334&lt;15/16&gt;mindist=2.8 step=0.0625 total=0.6875 logdisc=0.655
334&lt;15/16&gt;mindist=2.85 step=0.0625 total=0.75 logdisc=0.682
334&lt;15/16&gt;mindist=2.9 step=0.0625 total=0.8125 logdisc=0.709
334&lt;15/16&gt;mindist=2.95 step=0.0625 total=0.875 logdisc=0.736
334&lt;15/16&gt;mindist=3.01 step=0.0625 total=0.9375 logdisc=0.764
# Minimal distance==2.55
# Minimal step==0.0625==-0.0521 + 0.0104im
# Adaptivity==10
monodromy[15]=[2]

# segment 15/16 Time==0.002741098403930664sec</code></pre><p>Here  at each step the following  information is displayed: first, how many iterations  of the Newton  method were necessary  to compute each  of the 3 roots  of the current polynomial  <code>f(x,y‚ÇÄ)</code> if we are  looking at the point <code>y‚ÇÄ</code> of the segment. Then, which segment we are dealing with (here the 15th of  16 in all).  Then the minimum  distance between two  roots of <code>f(x,y‚ÇÄ)</code> (used  in our heuristic). Then the current  step in fractions of the length of  the segment we are looking at, and the total fraction of the segment we have  done. Finally,  the decimal  logarithm of  the absolute  value of the discriminant  at the  current point  (used in  the heuristic).  Finally, an indication  if  the  heuristic  predicts  that  we  should  halve  the step <code>***rejected</code> or that we may double it <code>***up</code>.</p><p>The function returns an element of the ambient braid group <code>r.B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/VKcurve.jl/blob/3f51930ef2146615bfe9bdcfe6e35a48a92cd8c9/src/VKcurve.jl#L1032-L1102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VKcurve.Lbraid2braid"><a class="docstring-binding" href="#VKcurve.Lbraid2braid"><code>VKcurve.Lbraid2braid</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p><code>VKcurve.Lbraid2braid(v1,v2,B)</code></p><p>This function converts  the linear braid joining the points in <code>v1</code> to the corresponding ones in <code>v2</code> into an element of the braid group.</p><pre><code class="language-julia-repl hljs">julia&gt; B=BraidMonoid(coxsym(3))
BraidMonoid(ùîñ ‚ÇÉ)

julia&gt; VKcurve.Lbraid2braid([1+im,2+im,3+im],[2+im,1+2im,4-6im],B)
1</code></pre><p>The lists <code>v1</code> and <code>v2</code> must have the same length, say <code>n</code>. Then <code>B</code> should be  <code>BraidMonoid(coxsym(n))</code>, the braid group  on <code>n</code> strings. The elements of  <code>v1</code> (resp. <code>v2</code>)  should be <code>n</code>  distinct complex rational numbers. We use the Brieskorn basepoint, namely the contractible set <code>C+iV_‚Ñù</code> where <code>C</code> is  a real chamber; therefore the endpoints  need not be equal. The strings defined  by <code>v1</code> and <code>v2</code> should be  non-crossing. When the numbers in <code>v1</code> (resp.  <code>v2</code>)  have  distinct  real  parts,  the  real picture of the braid defines a unique element of <code>B</code>. When some real parts are equal, we apply a lexicographical  desingularization, corresponding to a rotation of <code>v1</code> and <code>v2</code> by an arbitrary small positive angle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/VKcurve.jl/blob/3f51930ef2146615bfe9bdcfe6e35a48a92cd8c9/src/VKcurve.jl#L1426-L1449">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VKcurve.VKquotient"><a class="docstring-binding" href="#VKcurve.VKquotient"><code>VKcurve.VKquotient</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><p><code>VKcurve.VKquotient(braids)</code></p><p>The  input <code>braids</code> is a list <code>b‚ÇÅ,‚Ä¶,bn</code>, living in the braid group on <code>m</code> strings. Each <code>b·µ¢</code> defines by Hurwitz action an automorphism <code>œÜ·µ¢</code> of the free group <code>F‚Çô</code>. The function returns the group defined by the abstract presentation: <span>$&lt; f‚ÇÅ,‚Ä¶,f‚Çô ‚à£ ‚àÄ i,j œÜ·µ¢(f‚±º)=f‚±º &gt;$</span></p><pre><code class="language-julia-repl hljs">julia&gt; B=BraidMonoid(coxsym(3))
BraidMonoid(ùîñ ‚ÇÉ)

julia&gt; g=VKcurve.VKquotient([B(1,1,1),B(2)])
FreeGroup(a,b,c)/[b‚Åª¬πa‚Åª¬πbaba‚Åª¬π,b‚Åª¬πa‚Åª¬πb‚Åª¬πaba,.,.,cb‚Åª¬π,c‚Åª¬πb]

julia&gt; p=Presentation(g)
Presentation: 3 generators, 4 relators, total length 16</code></pre><pre><code class="language-julia-rep1 hljs">julia&gt; display_balanced(p)
1: c=b
2: b=c
3: bab=aba
4: aba=bab

julia&gt; simplify(p)
Presentation: 2 generators, 1 relator, total length 6
Presentation: 2 generators, 1 relator, total length 6

julia&gt; display_balanced(p)
1: bab=aba</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmichel7/VKcurve.jl/blob/3f51930ef2146615bfe9bdcfe6e35a48a92cd8c9/src/VKcurve.jl#L1507-L1540">source</a></section></details></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 26 November 2025 16:25">Wednesday 26 November 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
