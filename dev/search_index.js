var documenterSearchIndex = {"docs":
[{"location":"#VKcurve","page":"Home","title":"VKcurve","text":"Documentation for VKcurve.","category":"section"},{"location":"#VKcurve.VKcurve","page":"Home","title":"VKcurve.VKcurve","text":"This  package is  a port  to Julia  of the  GAP3 package VKcurve written by David Bessis and Jean Michel in 2002.\n\nThe  main function  computes the  fundamental group  of the complement of a complex  algebraic curve in â„‚Â², using an implementation of the Van Kampen method; see for example\n\nD. Cheniot. \"Une dÃ©monstration du thÃ©orÃ¨me de   Zariski sur les sections hyperplanes d'une hypersurface projective et du   thÃ©orÃ¨me de Van Kampen sur le groupe fondamental du   complÃ©mentaire d'une courbe projective plane.\" Compositio Math., 27:141â€“158, 1973.\n\nfor a clear and modernized account of this method. Here is are examples for curves defined as the zeros of two-variable polynomials in x and y.\n\njulia> using PuiseuxPolynomials, VKcurve\n\njulia> @Mvp x,y\n\njulia> fundamental_group((x+y)*(x-y*im)*(x+2*y))\nPresentation: 3 generators, 2 relators, total length 12\n1: abc=bca\n2: cab=abc\n\njulia> r=fundamental_group(x^2-y^3); # the braid group on 3 strands\nPresentation: 2 generators, 1 relator, total length 6\n\njulia> r\n1: bab=aba\n\nHere we define the variables and then give the curves as argument. Although approximate  computations are used  in several places,  they are controlled and  the final result is exact;  technically speaking, the computations use Rational{BigInt} or Complex{Rational{BigInt}} since the precision given by  floats  is  insufficient.  It  might  be  possible  to use intervals of bigfloats  to make calculations faster, but this would make the programming more  difficult.  If  you  have  a  polynomial with float coefficients, you should convert the coefficients to Complex{Rational{BigInt}} (if they are of  any integer or rational type, or of type Complex{<:Integer} they will be converted internally to Complex{Rational{BigInt}}).\n\nThe  output is  a struct  which contains  a lot  of information about the calculation,  including a  presentation of  the computed fundamental group, which is what is displayed by default when printing it.\n\nOur  motivation  for  writing  this  package  in  2002 was to find explicit presentations  for generalized braid groups associated with certain complex reflection  groups. Although presentations were known for almost all cases, six  exceptional cases were missing (in the notations of Shephard and Todd, these  cases are  Gâ‚‚â‚„, Gâ‚‚â‚‡,  Gâ‚‚â‚‰, Gâ‚ƒâ‚,  Gâ‚ƒâ‚ƒ and Gâ‚ƒâ‚„). Since the existence of nice presentations for braid groups was proved (non-constructively) in\n\nD. Bessis. \"Zariski theorems and diagrams for braid groups.\", Invent. Math. 145:487â€“507, 2001\n\nit  was upsetting not to  know them explicitly. In  the absence of any good grip  on the  geometry of  these six  examples, brute force (using VKcurve) gave  us we have  obtained presentations for  all of them  (they have since been  confirmed by less  computational methods). These  computations can be reproduced by fundamental_group(VKcurve.data[i]) where iâˆˆ{23,24,27,29,31,33,34}.\n\nIf  you  are  not  interested  in  the  details  of  the  algorithm, and if fundamental_group,  as  in  the  examples  above,  gives you satisfactory answers  in a reasonable time, then you do not need to read this manual any further.\n\nIn  order to implement the algorithm, we had to write auxiliary facilities, for  example to find Complex{Rational} approximations of zeros of complex polynomials,  or to work with piecewise  linear braids, which can be useful facilities in themselves. These are documented in this manual.\n\nBefore  discussing  our  actual  implementation,  let  us  give an informal summary  of the mathematical  background. Our strategy  is adapted from the one  originally described in the 1930's by Van Kampen. Let C be an affine algebraic  curve, given as the  set of zeros in  â„‚Â² of a non-zero reduced polynomial  P(x,y).  The  problem  is  to  compute  a presentation of the fundamental  group of  â„‚Â²-C. Consider  P as  a polynomial  in x, with coefficients  in the ring  of polynomials in  y, that is P=Î±â‚€(y)xâ¿+Î±â‚(y) xâ¿â»Â¹+â€¦+Î±â‚™â‚‹â‚(y)x+Î±â‚™(y), where the Î±áµ¢âˆˆâ„‚[y]. Let Î”(y) be the discriminant of  P or, in other words, the resultant  of P and âˆ‚P/âˆ‚x. Since P is reduced,  Î” is non-zero. Let yâ‚,â€¦,y_d be the roots of the corresponding reduced polynomial Î”_{red}. For a generic value of y, the polynomial in x  given by  P(x,y) has  n distinct  roots. When  y=yâ±¼, with j in 1,â€¦,d,  we  are  in  exactly  one  of  the  following  situations: either P(x,yâ±¼)=0  (we then say that  yâ±¼ is bad), or  P(x,yâ±¼) has a number of roots  in  x  strictly  smaller  than  n.  Fix  yâ‚€ in â„‚-{yâ‚,â€¦,y_d}. Consider  the projection p:  â„‚Â²â†’ â„‚, (x,y)â†¦  y. It restricts  to a locally trivial  fibration with base space B=â„‚-{yâ‚,â€¦,y_d} and fibers homeomorphic to  the complex plane with  n points removed. We  denote by E the total space pâ»Â¹(B) and by F the fiber over yâ‚€. The fundamental group of F is  isomorphic to the free group on n generators. Let Î³â‚,â€¦,Î³_d be loops in  the  pointed  space  (B,yâ‚€)  representing  a  generating  system  for Ï€â‚(B,yâ‚€).  By trivializing  the pullback  of p  along Î³áµ¢,  one gets a (well-defined  up to  isotopy) homeomorphism  of F,  and a (well-defined) automorphism Ï†áµ¢ of the fundamental group of F, identified with the free group Fâ‚™ by the choice of a generating system fâ‚,â€¦,fâ‚™. An effective way of  computing Ï†áµ¢ is by following the solutions in x of P(x,y)=0, when y  moves along Ï†áµ¢. This defines a loop in the space of configuration of n  points in a plane, hence an element  báµ¢ of the braid group Bâ‚™ (via an  identification of Bâ‚™ with the fundamental group of this configuration space).  Let Ï† be the Hurwitz action of  Bâ‚™ on Fâ‚™. All choices can be made in such a way that Ï†áµ¢=Ï†(báµ¢). The theorem of Van Kampen asserts that, if  there are  no bad  roots of  the discriminant,  a presentation  for the fundamental group of â„‚Â²-C is âŸ¨fâ‚,â€¦,fâ‚™âˆ£âˆ€i,j,Ï†áµ¢(fâ±¼)=fâ±¼âŸ©. A variant of the above  presentation (see VKquotient) can be used to deal with bad roots of the discriminant.\n\nThis algorithm is implemented in the following way.\n\nAs input, we have a polynomial P. We reduce P if it was not.\nThe discriminant Î” of P with respect to x, a polynomial in y, is computed.\nThe  roots  of  Î”  are  approximated,  via  the  following procedure. First,  we reduce Î” and get  Î”_{red} (generating the radical of the ideal  generated  by  Î”).  The  roots  {yâ‚,â€¦,y_d}  of Î”_{red} are separated  by separate_roots (which  uses Newton's method and continuous fraction aprroximations).\nLoops around these roots are computed by loops_around_punctures. This  function first computes  some sort of  honeycomb, consisting of a set  S of  affine segments,  isolating the  yáµ¢. Since  it makes the computation  of the monodromy  more effective, each  inner segment is a fragment  of the mediatrix of two roots of Î”. Then a vertex of one of the  segments is chosen as a basepoint, and the function returns a list of  lists of oriented segments  in S: each list of segments encodes a piecewise linear loop Î³áµ¢ circling one of yáµ¢.\nFor each  segment in  S, we  compute the  monodromy braid obtained by following  the solutions in x of  P(x,y)=0 when y moves along the segment. By default, this monodromy braid is computed by follow_monodromy. The strategy is to compute a piecewise-linear  braid  approximating  the  actual monodromy geometric braid. The approximations are controlled. The piecewise-linear braid is constructed  step-by-step, by computations of linear pieces. As soon as new  piece is constructed, it is converted  into an element of Bâ‚™ and multiplied; therefore, though the braid may consist of a huge number of pieces, the function follow_monodromy works with constant memory. The package  also  contains  a  variant  approx_follow_monodromy, which runs faster, but without guarantee on the result (see below).\nThe monodromy braids báµ¢ corresponding  to the loops Î³áµ¢ are obtained by  multiplying the monodromy braids  of the correponding segments. The action  of these elements of Bâ‚™ on the free group Fâ‚™ is computed by hurwitz  and the resulting  presentation of the  fundamental group is computed  by VKquotient.  It happens  for some large problems that the whole process fails here, because the braids báµ¢ obtained are too  long and the computation  of the action on  Fâ‚™ requires thus too much  memory. We have been able to  solve such problems when they occur by  calling at  this stage  our function  shrink which  finds smaller generators  for the  subgroup of  Bâ‚™ generated  by the  báµ¢ (see the description   in   Chevie.Garside).   This   function  is  called  if VK.shrinkBraid==true.\nFinally, the presentation is simplified by simplify. This function is a   heuristic   function   for   simplifying   presentations.   It   is non-deterministic.\n\nFrom  an algorithmic point of view, memory  should not be an issue, but the procedure  can  take  a  lot  of  CPU  time  (the  critical  part being the computation of the monodromy braids by follow_monodromy). For example, an empirical  study with  the curves  xÂ²-yâ¿ suggests  that the time required grows  exponentially with n.  The variable VK.approx_monodromy controls which  monodromy function  is used.  The default  value of this variable is false,  which means that  follow_monodromy is used.  If the variable is set  to true then approx_follow_monodromy is used, where approximations are   no   longer   controlled.   Therefore  presentations  obtained  while VK.approx_monodromy  is  set  to  true  will not be certified. However, while  it is likely that there are examples where approx_follow_monodromy actually returns incorrect answers, we have not yet seen any.\n\n\n\n\n\n","category":"module"},{"location":"#Chevie.Semisimple.fundamental_group-Tuple{PuiseuxPolynomials.Mvp}","page":"Home","title":"Chevie.Semisimple.fundamental_group","text":"fundamental_group(curve::Mvp; verbose=0)\n\ncurve should be an Mvp in x and y representing an equation f(x,y) for  a  curve  in  â„‚Â².  The  coefficients  should be integers, rationals, gaussian  integers or  gaussian rationals.  The result  is a  record with a certain number of fields which record steps in the computation described in this introduction:\n\njulia> @Mvp x,y\n\njulia> r=fundamental_group(x^2-y^3)\nPresentation: 2 generators, 1 relator, total length 6\n1: bab=aba\n\njulia> propertynames(r)\n(:curve, :ismonic, :prop, :rawPresentation, :B, :basepoint, :dispersal, :monodromy, :discyFactored, :segments, :braids, :roots, :nonVerticalPart, :discy, :zeros, :curveVerticalPart, :points, :loops, :presentation)\n\njulia> r.curve # the given equation\nMvp{Rational{BigInt}}: (1//1)xÂ²+(-1//1)yÂ³\n\njulia> Pol(:y);r.discy # its discriminant wrt x\nPol{Rational{BigInt}}: y\n\njulia> r.roots  # roots of the discriminant\n1-element Vector{Rational{BigInt}}:\n 0\n\njulia> r.points # for points, segments and loops see loops_around_punctures\n4-element Vector{Complex{Rational{BigInt}}}:\n  0//1 - 1//1*im\n -1//1 + 0//1*im\n  1//1 + 0//1*im\n  0//1 + 1//1*im\n\njulia> r.segments\n4-element Vector{Vector{Int64}}:\n [1, 2]\n [1, 3]\n [2, 4]\n [3, 4]\n\njulia> r.loops\n1-element Vector{Vector{Int64}}:\n [4, -3, -1, 2]\n\njulia> r.zeros # zeroes of curve(y=pt) when pt runs over r.points\n4-element Vector{Vector{Complex{Rational{BigInt}}}}:\n [5741//8119 + 5741//8119*im, -5741//8119 - 5741//8119*im]\n [0//1 + 1//1*im, 0//1 - 1//1*im]\n [1//1 + 0//1*im, -1//1 + 0//1*im]\n [-5741//8119 + 5741//8119*im, 5741//8119 - 5741//8119*im]\n\njulia> r.monodromy # monodromy around each r.segment\n4-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:\n (Î”)â»Â¹\n Î”\n .\n Î”\n\njulia> r.braids # monodromy around each r.loop\n1-element Vector{GarsideElt{Perm{Int16}, BraidMonoid{Perm{Int16}, CoxSym{Int16}}}}:\n Î”Â³\n\njulia> display_balanced(r.presentation) # printing of r by default\n1: bab=aba\n\nThe  keyword argument verbose triggers the  display of information on the progress of the computation. It is recommended to set it at 1 or 2 when the computation seems to take a long time without doing anything. verbose set at  0 is the default and prints nothing; set at 1 it shows which segment is currently  active,  and  set  at  2  it  traces the computation inside each segment.\n\njulia> fundamental_group(x^2-y^3,verbose=1);\n# There are 4 segments in 1 loops\n# follow_monodromy along segment 1/4  in   8 steps/  0.012sec got B(-1)\n# follow_monodromy along segment 2/4  in   8 steps/ 0.00752sec got B(1)\n# follow_monodromy along segment 3/4  in   8 steps/ 0.00557sec got B()\n# follow_monodromy along segment 4/4  in   8 steps/ 0.00457sec got B(1)\n# Computing monodromy braids along loops\n[r.B(1,1,1),]\n#I total length 3 maximal length 3\n\nPresentation: 2 generators, 1 relator, total length 6\n\n\n\n\n\n","category":"method"},{"location":"#VKcurve.simp","page":"Home","title":"VKcurve.simp","text":"VKcurve.simp(t::Real;prec=10^-15,type=BigInt)\n\nsimplest fraction of type Rational{T} approximating t closer than prec.\n\njulia> VKcurve.simp(float(Ï€);prec=10^-6)\n355//113\n\n\n\n\n\n","category":"function"},{"location":"#VKcurve.NewtonRoot","page":"Home","title":"VKcurve.NewtonRoot","text":"VKcurve.NewtonRoot(p::Pol,initial_guess,precision::Real;showall=false,show=false,lim=800)\n\nHere   p  is   a  polynomial   with  Rational   or  Complex{Rational} coefficients.  The function  computes an  approximation to  a root  of p, guaranteed of distance closer than precision to an actual root. The first approximation  used is initial.  A possibility is  that the Newton method starting  from initial does not converge  (the number of iterations after which  this is decided  is controlled by  lim); then the function returns nothing.  Otherwise the function returns a pair: the approximation found, and an upper bound on the distance between that approximation and an actual root.  The point of returning  an upper bound is  that it is usually better than the asked-for precision. For the precision estimate a good reference is\n\nJ.  Hubbard, D. Schleicher,  and S. Sutherland.  \"How to find  all roots of complex polynomials by Newton's method.\", Invent. Math. 146:1â€“33, 2001.\n\njulia> p=Pol([1,0,1])\nPol{Int64}: yÂ²+1\n\njulia> VKcurve.NewtonRoot(p,1+im,10^-7)\n(0//1 + 1//1*im, 3.3333333333333337e-10)\n\njulia> VKcurve.NewtonRoot(p,1,10^-7;show=true)\n****** Non-Convergent Newton after 800 iterations ******\np=yÂ²+1 initial=-1.0 prec=1.0000000000000004e-7\n\n\n\n\n\n","category":"function"},{"location":"#VKcurve.separate_roots","page":"Home","title":"VKcurve.separate_roots","text":"VKcurve.separate_roots(p::Pol, safety)\n\nHere  p is  a complex  polynomial. The  result is  a list  l of complex numbers  representing approximations to the roots  of p, such that if d is  the minimum distance between two elements  of l, then there is a root of  p within  radius d/(2*safety)  of any  element of  l. This is not possible when p has multiple roots, in which case nothing is returned.\n\njulia> @Pol q\nPol{Int64}: q\n\njulia> VKcurve.separate_roots(q^2+1,100)\n2-element Vector{Complex{Rational{BigInt}}}:\n 0//1 + 1//1*im\n 0//1 - 1//1*im\n\njulia> VKcurve.separate_roots((q-1)^2,100)\n\njulia> VKcurve.separate_roots(q^3-1,100)\n3-element Vector{Complex{Rational{BigInt}}}:\n -1//2 - 181//209*im\n  1//1 + 0//1*im\n -1//2 + 181//209*im\n\n\n\n\n\n","category":"function"},{"location":"#VKcurve.find_roots","page":"Home","title":"VKcurve.find_roots","text":"VKcurve.find_roots(p::Pol, approx)\n\np  should have rational or  Complex{Rational} coefficients. The function returnsComplexrational  approximations to  the roots  ofpwhich are better  thanapprox(a  positive  rational).  Contrary to the functionsseparate_roots`,  etc... described in the  previous chapter, this function handles  quite  well  polynomials  with  multiple  roots.  We  rely  on the algorithms explained in detail in cite{HSS01}.\n\njulia> VKcurve.find_roots((Pol()-1)^5,1/1000)\n5-element Vector{Complex{Rational{BigInt}}}:\n 1//1 + 0//1*im\n 1//1 + 0//1*im\n 1//1 + 0//1*im\n 1//1 + 0//1*im\n 1//1 + 0//1*im\n\njulia> l=VKcurve.find_roots(Pol()^3-1,10^-5)\n3-element Vector{Complex{Rational{BigInt}}}:\n -1//2 - 16296//18817*im\n  1//1 + 0//1*im\n -1//2 + 16296//18817*im\n\njulia> round.(Complex{Float64}.(l.^3);sigdigits=3)\n3-element Vector{ComplexF64}:\n 1.0 - 1.83e-9im\n 1.0 + 0.0im\n 1.0 + 1.83e-9im\n\n\n\n\n\n","category":"function"},{"location":"#VKcurve.nearest_pair","page":"Home","title":"VKcurve.nearest_pair","text":"VKcurve.nearest_pair(v::Vector{<:Complex})\n\nreturns  a pair whose first element is the minimum distance (in the complex plane)  between two elements  of v, and  the second is  a pair of indices [i,j] such that v[i],v[j] achieves this minimum.\n\njulia> nearest_pair([1+im,0,1]) 1=>[1,3]\n\n\n\n\n\n","category":"function"},{"location":"#VKcurve.dist_seg","page":"Home","title":"VKcurve.dist_seg","text":"dist_seg(z,a,b) distance (in the complex plane) of z to segment [a,b] \n\n\n\n\n\n","category":"function"},{"location":"#VKcurve.loops_around_punctures","page":"Home","title":"VKcurve.loops_around_punctures","text":"VKcurve.loops_around_punctures(points)\n\npoints  should  be  a  list  of  complex  numbers.  The function computes piecewise-linear  loops representing generators of the fundamental group of â„‚ -{points}.\n\njulia> VKcurve.loops_around_punctures([0])\n1-element Vector{Vector{Complex{Int64}}}:\n [1 + 0im, 0 + 1im, -1 + 0im, 0 - 1im, 1 + 0im]\n\nGuarantees on the result: for  a set Z of zeroes and zâˆˆZ, let R(z):=dist(z,Z-z)/2. The input of points  is a set Z of approximate zeroes of r.discy such that for any z  one  of  the  zeroes  is  closer  than  R(z)/S where S is a global constant   of  the  program   (in  practice  we   may  take  S=100).  Let d=inf_{zâˆˆZ}(R(z));   we  return   points  with   denominator  10^-k  or 10^-k<d/S' (in practive we take S'=100) and such that the distance of a segment to a zero of r.discy is guaranteed >= d-d/S'-d/S.\n\n\n\n\n\n","category":"function"},{"location":"#VKcurve.convert_loops","page":"Home","title":"VKcurve.convert_loops","text":"VKcurve.convert_loops(ll)\n\nThe  input is a list  of loops, each a  list of complex numbers representing the vertices of the loop.\n\nThe output is a named tuple with fields\n\npoints: a list of complex  numbers.\nsegments:  a list of oriented segments, each of them  encoded by the list of the positions in points of  its two endpoints.\nloops: a list of loops. Each loops is a list  of integers representing a  piecewise  linear  loop,  obtained  by  concatenating the segments indexed  by the  integers, where  a negative  integer is  used when the opposed orientation of the segment is taken.\n\n\n\n\n\n","category":"function"},{"location":"#VKcurve.follow_monodromy","page":"Home","title":"VKcurve.follow_monodromy","text":"VKcurve.follow_monodromy(r,segno) This  function computes the  monodromy braid of  the solution in  x of an equation   P(x,y)=0  along   a  segment   [yâ‚€,yâ‚].  It   is  called  by fundamental_group  for each  segment in  turn. The  first argument is the record containing intermediate information computed by fundamental_group. The second argument is the index of the segment in r.segments.\n\nThe function returns an element of the ambient braid group r.B.\n\nThis function has no reason to be called directly by the user, so we do not illustrate  its behavior. Instead,  we explain what  is displayed on screen when the user sets verbose=2.\n\nWhat is quoted below is an excerpt of what is printed during the execution of\n\njulia> fundamental_group((x+3*y)*(x+y-1)*(x-y),verbose=2)\n......\nsegment 1/16 step   1 time=0           ?2?1?3\nsegment 1/16 step   2 time=0.2         R2. ?3\nsegment 1/16 step   3 time=0.48        R2. ?2\nsegment 1/16 step   4 time=0.74        ?2R1?2\nsegment 1/16 step   5 time=0.94        R1. ?2\n======================================\n==    Nontrivial braiding B(2)      ==\n======================================\nsegment 1/16 step   6 time=0.bc        R1. ?1\nsegment 1/16 step   7 time=0.d8        . ?0. \nsegment 1/16 step   8 time=0.dc        ?1R0?1\n# follow_monodromy(segment 1/16) in   8 steps/ 0.0209sec got B(2)\n\nfollow_monodromy  computes its  results by  subdividing the  segment into smaller  subsegments on which the  approximations are controlled. It starts at  one end and moves subsegment after  subsegment. A new line is displayed at each step.\n\nThe  first column indicates which segment  is studied. The second column is the  number of iterations  so far (number  of subsegments). In our example, follow_monodromy  had  to  cut  the  segment  into  8 subsegments. Each subsegment  has its own length. The cumulative length at a given step, as a fraction  of the total  length of the  segment, is displayed after time=. This  gives a rough  indication of the  time left before  completion of the computation of the monodromy of this segment. The segment is completed when this fraction reaches 1.\n\nThe  last column has  to do with  the piecewise-linear approximation of the geometric  monodromy  braid.  It  is  subdivided  into sub-columns for each string.  In the example above, there are  three strings. At each step, some strings are fixed (they are indicated by . in the corresponding column). A  symbol like R5 or ?3 indicates  that the string is moving. The exact meaning   of  the  symbol  has  to   do  with  the  complexity  of  certain sub-computations.\n\nAs  some strings are moving, it  happens that their real projections cross. When  such a crossing occurs, it  is detected and the corresponding element of  Bâ‚™ is displayed (Nontrivial braiding  =...). The monodromy braid is the  product of these  elements of Bâ‚™,  multiplied in the  order in which they occur.\n\n\n\n\n\n","category":"function"},{"location":"#VKcurve.approx_follow_monodromy","page":"Home","title":"VKcurve.approx_follow_monodromy","text":"VKcurve.approx_follow_monodromy(<r>,<segno>,<pr>)\n\nThis function  computes an approximation  of the monodromy braid  of the solution in x  of an equation P(x,y)=0 along  a segment [yâ‚€,yâ‚]. It is called  by fundamental_group, once for each of  the segments. The first  argument is  a  global record,  similar to  the  one produced  by fundamental_group  (see the  documentation of  this function)  but only containing intermediate information. The second argument is the position of the segment in r.segments. \n\nContrary  to follow_monodromy, approx_follow_monodromy does not control the approximations; it just uses a heuristic for how much to move along the segment  between linear braid computations, and this heuristic may possibly fail.  However, we have  not yet found  an example for  which the result is actually  incorrect, and thus  the existence is  justified by the fact that for  some difficult  computations, it  is sometimes  many times faster than follow_monodromy. We illustrate its typical output when verbose=2:\n\njulia> VK.approx_monodromy=true\n\njulia> fundamental_group((x+3*y)*(x+y-1)*(x-y);verbose=2)\n\n  ....\n\n546 ***rejected\n447<15/16>mindist=2.55 step=0.5 total=0 logdisc=0.55 ***rejected\n435<15/16>mindist=2.55 step=0.25 total=0 logdisc=0.455 ***rejected\n334<15/16>mindist=2.55 step=0.125 total=0 logdisc=0.412 ***rejected\n334<15/16>mindist=2.55 step=0.0625 total=0 logdisc=0.393\n334<15/16>mindist=2.55 step=0.0625 total=0.0625 logdisc=0.412\n334<15/16>mindist=2.56 step=0.0625 total=0.125 logdisc=0.433\n334<15/16>mindist=2.57 step=0.0625 total=0.1875 logdisc=0.455\n334<15/16>mindist=2.58 step=0.0625 total=0.25 logdisc=0.477\n======================================\n==    Nontrivial braiding B(2)      ==\n======================================\n334<15/16>mindist=2.6 step=0.0625 total=0.3125 logdisc=0.501\n334<15/16>mindist=2.63 step=0.0625 total=0.375 logdisc=0.525\n334<15/16>mindist=2.66 step=0.0625 total=0.4375 logdisc=0.55\n334<15/16>mindist=2.69 step=0.0625 total=0.5 logdisc=0.576\n334<15/16>mindist=2.72 step=0.0625 total=0.5625 logdisc=0.602\n334<15/16>mindist=2.76 step=0.0625 total=0.625 logdisc=0.628\n334<15/16>mindist=2.8 step=0.0625 total=0.6875 logdisc=0.655\n334<15/16>mindist=2.85 step=0.0625 total=0.75 logdisc=0.682\n334<15/16>mindist=2.9 step=0.0625 total=0.8125 logdisc=0.709\n334<15/16>mindist=2.95 step=0.0625 total=0.875 logdisc=0.736\n334<15/16>mindist=3.01 step=0.0625 total=0.9375 logdisc=0.764\n# Minimal distance==2.55\n# Minimal step==0.0625==-0.0521 + 0.0104im\n# Adaptivity==10\nmonodromy[15]=[2]\n\n# segment 15/16 Time==0.002741098403930664sec\n\nHere  at each step the following  information is displayed: first, how many iterations  of the Newton  method were necessary  to compute each  of the 3 roots  of the current polynomial  f(x,yâ‚€) if we are  looking at the point yâ‚€ of the segment. Then, which segment we are dealing with (here the 15th of  16 in all).  Then the minimum  distance between two  roots of f(x,yâ‚€) (used  in our heuristic). Then the current  step in fractions of the length of  the segment we are looking at, and the total fraction of the segment we have  done. Finally,  the decimal  logarithm of  the absolute  value of the discriminant  at the  current point  (used in  the heuristic).  Finally, an indication  if  the  heuristic  predicts  that  we  should  halve  the step ***rejected or that we may double it ***up.\n\nThe function returns an element of the ambient braid group r.B.\n\n\n\n\n\n","category":"function"},{"location":"#VKcurve.Lbraid2braid","page":"Home","title":"VKcurve.Lbraid2braid","text":"VKcurve.Lbraid2braid(v1,v2,B)\n\nThis function converts  the linear braid joining the points in v1 to the corresponding ones in v2 into an element of the braid group.\n\njulia> B=BraidMonoid(coxsym(3))\nBraidMonoid(ð”– â‚ƒ)\n\njulia> VKcurve.Lbraid2braid([1+im,2+im,3+im],[2+im,1+2im,4-6im],B)\n1\n\nThe lists v1 and v2 must have the same length, say n. Then B should be  BraidMonoid(coxsym(n)), the braid group  on n strings. The elements of  v1 (resp. v2)  should be n  distinct complex rational numbers. We use the Brieskorn basepoint, namely the contractible set C+iV_â„ where C is  a real chamber; therefore the endpoints  need not be equal. The strings defined  by v1 and v2 should be  non-crossing. When the numbers in v1 (resp.  v2)  have  distinct  real  parts,  the  real picture of the braid defines a unique element of B. When some real parts are equal, we apply a lexicographical  desingularization, corresponding to a rotation of v1 and v2 by an arbitrary small positive angle.\n\n\n\n\n\n","category":"function"},{"location":"#VKcurve.VKquotient","page":"Home","title":"VKcurve.VKquotient","text":"VKcurve.VKquotient(braids)\n\nThe  input braids is a list bâ‚,â€¦,bn, living in the braid group on m strings. Each báµ¢ defines by Hurwitz action an automorphism Ï†áµ¢ of the free group Fâ‚™. The function returns the group defined by the abstract presentation:  fâ‚fâ‚™   ij Ï†áµ¢(fâ±¼)=fâ±¼ \n\njulia> B=BraidMonoid(coxsym(3))\nBraidMonoid(ð”– â‚ƒ)\n\njulia> g=VKcurve.VKquotient([B(1,1,1),B(2)])\nFreeGroup(a,b,c)/[bâ»Â¹aâ»Â¹babaâ»Â¹,bâ»Â¹aâ»Â¹bâ»Â¹aba,.,.,cbâ»Â¹,câ»Â¹b]\n\njulia> p=Presentation(g)\nPresentation: 3 generators, 4 relators, total length 16\n\njulia> display_balanced(p)\n1: c=b\n2: b=c\n3: bab=aba\n4: aba=bab\n\njulia> simplify(p)\nPresentation: 2 generators, 1 relator, total length 6\nPresentation: 2 generators, 1 relator, total length 6\n\njulia> display_balanced(p)\n1: bab=aba\n\n\n\n\n\n","category":"function"}]
}
